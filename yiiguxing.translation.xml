<application>
  <component name="AppStorage">
    <option name="lastLanguages">
      <language-pair target="CHINESE" />
    </option>
    <histories>
      <item value="metasser" />
      <item value="metar" />
      <item value="metaor" />
      <item value="metaaor" />
      <item value="meta" />
      <item value="黏上" />
      <item value="绑定" />
      <item value="atanch" />
      <item value="atach" />
      <item value="relative" />
      <item value="相对的" />
      <item value="绝对" />
      <item value="illegal" />
      <item value="访问次数" />
      <item value="访问" />
      <item value="目录" />
      <item value="物理" />
      <item value="虚拟路径" />
      <item value="获取" />
      <item value="Retrival" />
      <item value="Load" />
      <item value="资源文件" />
      <item value="资源" />
      <item value="自定义" />
      <item value="符号" />
      <item value="splitted" />
      <item value="split" />
      <item value="切开的" />
      <item value="切分的" />
      <item value="splited" />
      <item value="splite" />
      <item value="wu manber" />
      <item value="wumanber" />
      <item value="manber" />
      <item value="stash" />
      <item value="joinnable" />
      <item value="joinable" />
      <item value="下一级" />
      <item value="挖掘" />
      <item value="Retrieval" />
      <item value="分词器" />
      <item value="分瓷器" />
      <item value="// The append built-in function appends elements to the end of a slice. If&#10;// it has sufficient capacity, the destination is resliced to accommodate the&#10;// new elements. If it does not, a new underlying array will be allocated.&#10;// Append returns the updated slice. It is therefore necessary to store the&#10;// result of append, often in the variable holding the slice itself:&#10;//&#9;slice = append(slice, elem1, elem2)&#10;//&#9;slice = append(slice, anotherSlice...)&#10;// As a special case, it is legal to append a string to a byte slice, like this:&#10;//&#9;slice = append([]byte(&quot;hello &quot;), &quot;world&quot;...)" />
      <item value="剩下的" />
      <item value="Comodification" />
      <item value="/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the {@code iterator} and {@code listIterator} methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a {@code ConcurrentModificationException} in * response to the {@code next}, {@code remove}, {@code previous}, * {@code set} or {@code add} operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its {@code add(int, E)} and * {@code remove(int)} methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * {@code add(int, E)} or {@code remove(int)} must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus {@code ConcurrentModificationExceptions}. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */" />
      <item value="* The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the {@code iterator} and {@code listIterator} methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a {@code ConcurrentModificationException} in * response to the {@code next}, {@code remove}, {@code previous}, * {@code set} or {@code add} operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its {@code add(int, E)} and * {@code remove(int)} methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * {@code add(int, E)} or {@code remove(int)} must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus {@code ConcurrentModificationExceptions}. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored." />
      <item value="and after the element * that would be returned by {@link #previous}, if any." />
      <item value="* The element is inserted immediately before the element that * would be returned by {@link #next}, if any," />
      <item value="* Inserts the specified element into the list (optional operation). * The element is inserted immediately before the element that * would be returned by {@link #next}, if any, and after the element * that would be returned by {@link #previous}, if any." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="75" />
        <entry key="ENGLISH" value="75" />
        <entry key="DANISH" value="1" />
        <entry key="FRENCH" value="2" />
        <entry key="SPANISH" value="1" />
      </map>
    </option>
  </component>
</application>